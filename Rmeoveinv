from pathlib import Path
import re

TARGET_DIR = Path("/path/to/target/directory")
HOSTNAME_FILE = Path("/path/to/hostnames.txt")

SECTION_RE = re.compile(r"^\[(.+)]$")

def load_short_hostnames(path: Path) -> set[str]:
    with path.open("r", encoding="utf-8") as f:
        hostnames = {
            line.strip()
            for line in f
            if line.strip() and not line.strip().startswith("#")
        }

    # Guardrail: short names only
    invalid = [h for h in hostnames if "." in h]
    if invalid:
        raise ValueError(
            f"Hostname file must contain short names only, found: {invalid}"
        )

    return hostnames

def should_remove_line(line: str, short_hostnames: set[str]) -> bool:
    stripped = line.strip()

    # Ignore comments and blanks
    if not stripped or stripped.startswith("#"):
        return False

    # Extract hostname token
    fqdn = stripped.split()[0]

    for short in short_hostnames:
        if fqdn == short:
            return True
        if fqdn.startswith(short + "."):
            return True

    return False

def clean_inventory(file_path: Path, short_hostnames: set[str]) -> None:
    with file_path.open("r", encoding="utf-8") as f:
        lines = f.readlines()

    # --- Split into sections ---
    sections = []
    current = {"name": None, "lines": []}

    for line in lines:
        match = SECTION_RE.match(line.strip())
        if match:
            sections.append(current)
            current = {"name": match.group(1), "lines": [line]}
        else:
            current["lines"].append(line)

    sections.append(current)

    # --- Remove host lines, preserving original blank lines ---
    for section in sections:
        cleaned = []
        previous_removed = False

        for line in section["lines"]:
            if section["name"] and should_remove_line(line, short_hostnames):
                previous_removed = True
                continue

            # Remove only blank lines created by deletions
            if line.strip() == "" and previous_removed:
                previous_removed = False
                continue

            cleaned.append(line)
            previous_removed = False

        section["lines"] = cleaned

    # --- Identify empty base groups ---
    empty_groups = set()

    for section in sections:
        name = section["name"]
        if not name or ":" in name:
            continue

        has_hosts = any(
            line.strip() and not line.strip().startswith("#")
            for line in section["lines"][1:]
        )

        if not has_hosts:
            empty_groups.add(name)

    # --- Remove empty groups and their dependent sections ---
    final_sections = []

    for section in sections:
        name = section["name"]

        if not name:
            final_sections.append(section)
            continue

        base_group = name.split(":", 1)[0]

        if base_group in empty_groups:
            continue

        final_sections.append(section)

    # --- Write cleaned inventory back ---
    with file_path.open("w", encoding="utf-8") as f:
        for section in final_sections:
            f.writelines(section["lines"])

def main():
    short_hostnames = load_short_hostnames(HOSTNAME_FILE)

    for file_path in TARGET_DIR.iterdir():
        if file_path.is_file():
            clean_inventory(file_path, short_hostnames)

if __name__ == "__main__":
    main()
